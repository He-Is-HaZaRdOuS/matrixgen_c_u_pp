#pragma once
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <armadillo>
#include "../formats/matrix_formats.hpp"

class MatrixMarketReader {
public:
    static CSRMatrix load_csr(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + filename);
        }
        
        std::string line;
        // Skip comments
        while (std::getline(file, line)) {
            if (line[0] != '%') break;
        }
        
        // Read matrix dimensions
        int rows, cols, nnz;
        std::istringstream iss(line);
        iss >> rows >> cols >> nnz;
        
        std::cout << "Loading matrix: " << rows << " x " << cols << ", NNZ: " << nnz << std::endl;
        
        // Read data
        std::vector<int> row_indices, col_indices;
        std::vector<double> values;
        
        for (int i = 0; i < nnz; i++) {
            std::getline(file, line);
            std::istringstream data_iss(line);
            int row, col;
            double value;
            data_iss >> row >> col >> value;
            
            // Matrix Market uses 1-based indexing, convert to 0-based
            row_indices.push_back(row - 1);
            col_indices.push_back(col - 1);
            values.push_back(value);
        }
        
        file.close();
        
        // Convert to CSR format
        return convert_to_csr(rows, cols, row_indices, col_indices, values);
    }
    
    static void save_csr(const CSRMatrix& matrix, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file for writing: " + filename);
        }
        
        // Write header
        file << "%%MatrixMarket matrix coordinate real general" << std::endl;
        file << "% Generated by GPU-MatGen" << std::endl;
        file << matrix.rows << " " << matrix.cols << " " << matrix.nnz << std::endl;
        
        // Write data (convert back to 1-based indexing)
        for (int i = 0; i < matrix.rows; i++) {
            for (int j = matrix.row_ptr[i]; j < matrix.row_ptr[i + 1]; j++) {
                file << (i + 1) << " " << (matrix.col_ind[j] + 1) << " " << matrix.values[j] << std::endl;
            }
        }
        
        file.close();
        std::cout << "Matrix saved to: " << filename << std::endl;
    }
    
private:
    static CSRMatrix convert_to_csr(int rows, int cols, 
                                   const std::vector<int>& row_indices,
                                   const std::vector<int>& col_indices,
                                   const std::vector<double>& values) {
        CSRMatrix csr;
        csr.rows = rows;
        csr.cols = cols;
        csr.nnz = values.size();
        
        // Count non-zeros per row
        std::vector<int> row_count(rows, 0);
        for (int row : row_indices) {
            row_count[row]++;
        }
        
        // Build row_ptr
        csr.row_ptr.resize(rows + 1);
        csr.row_ptr[0] = 0;
        for (int i = 0; i < rows; i++) {
            csr.row_ptr[i + 1] = csr.row_ptr[i] + row_count[i];
        }
        
        // Fill col_ind and values
        csr.col_ind.resize(csr.nnz);
        csr.values.resize(csr.nnz);
        
        std::vector<int> current_pos(rows, 0);
        for (size_t i = 0; i < values.size(); i++) {
            int row = row_indices[i];
            int pos = csr.row_ptr[row] + current_pos[row];
            csr.col_ind[pos] = col_indices[i];
            csr.values[pos] = values[i];
            current_pos[row]++;
        }
        
        return csr;
    }
};