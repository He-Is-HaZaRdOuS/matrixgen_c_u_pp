#pragma once
#include <armadillo>
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <filesystem>
#include "formats/matrix_formats.hpp"

class MatrixMarketReader {
public:
    static CSRMatrix load_csr(const std::string& filename) {
        if (!std::filesystem::exists(filename)) {
            throw std::runtime_error("File does not exist: " + filename);
        }

        std::ifstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + filename);
        }

        std::string line;
        bool is_symmetric = false;
        bool is_pattern = false;

        /* Parse Matrix Market header */
        while (std::getline(file, line)) {
            if (line[0] == '%') {
                if (line.find("symmetric") != std::string::npos) {
                    is_symmetric = true;
                }
                if (line.find("pattern") != std::string::npos) {
                    is_pattern = true;
                }
                continue;
            }
            break;
        }

        /* Read dimensions */
        int rows, cols, nnz;
        std::istringstream iss(line);
        iss >> rows >> cols >> nnz;

        std::cout << "Loading matrix: " << rows << " x " << cols << ", NNZ: " << nnz;
        if (is_symmetric) std::cout << " (symmetric)";
        if (is_pattern) std::cout << " (pattern)";
        std::cout << std::endl;

        /* Read coordinate format data */
        std::vector<int> row_indices, col_indices;
        std::vector<double> values;

        row_indices.reserve(is_symmetric ? nnz * 2 : nnz);
        col_indices.reserve(is_symmetric ? nnz * 2 : nnz);
        values.reserve(is_symmetric ? nnz * 2 : nnz);

        int entries_read = 0;
        while (std::getline(file, line) && entries_read < nnz) {
            if (line.empty() || line[0] == '%') continue;

            std::istringstream data_iss(line);
            int row, col;
            double value = 1.0;

            data_iss >> row >> col;
            if (!is_pattern) {
                data_iss >> value;
            }

            /* Convert to 0-based */
            row--;
            col--;

            row_indices.push_back(row);
            col_indices.push_back(col);
            values.push_back(value);

            /* Add transpose for symmetric matrices */
            if (is_symmetric && row != col) {
                row_indices.push_back(col);
                col_indices.push_back(row);
                values.push_back(value);
            }

            entries_read++;
        }

        file.close();

        // Build sparse matrix using Armadillo
        arma::umat locations(2, row_indices.size());
        arma::vec vals(values.size());

        for (size_t i = 0; i < row_indices.size(); i++) {
            locations(0, i) = row_indices[i];
            locations(1, i) = col_indices[i];
            vals(i) = values[i];
        }

        arma::sp_mat temp(locations, vals, rows, cols);

        std::cout << "Processed NNZ: " << temp.n_nonzero
                  << " (density: " << (100.0 * temp.n_nonzero / (rows * cols)) << "%)"
                  << std::endl;

        return CSRMatrix::from_arma(temp);
    }

    static void save_csr(const CSRMatrix& matrix, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file for writing: " + filename);
        }

        file << "%%MatrixMarket matrix coordinate real general" << std::endl;
        file << "% Generated by GPU-MatGen" << std::endl;
        file << matrix.rows << " " << matrix.cols << " " << matrix.nnz << std::endl;

        for (int i = 0; i < matrix.rows; i++) {
            for (int j = matrix.row_ptr[i]; j < matrix.row_ptr[i + 1]; j++) {
                file << (i + 1) << " " << (matrix.col_ind[j] + 1) << " "
                     << matrix.values[j] << std::endl;
            }
        }

        file.close();
        std::cout << "Matrix saved to: " << filename << std::endl;
    }
};