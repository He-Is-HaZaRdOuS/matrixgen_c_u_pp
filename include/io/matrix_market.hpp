#pragma once
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <filesystem>
#include <vector>
#include <unordered_map>
#include <tuple>
#include <algorithm>
#include "formats/matrix_formats.hpp"

struct CoordHash {
    std::size_t operator()(const std::pair<int,int> &p) const {
        return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second)<<1);
    }
};

class MatrixMarketReader {
public:
    static CSRMatrix load_csr(const std::string &filename) {
        if (!std::filesystem::exists(filename))
            throw std::runtime_error("File does not exist: " + filename);

        std::ifstream file(filename);
        if (!file.is_open())
            throw std::runtime_error("Cannot open file: " + filename);

        std::string line;
        bool symmetric = false, pattern = false;

        // parse header
        while (std::getline(file, line)) {
            if (line.empty()) continue;
            if (line[0] != '%') break;
            if (line.find("symmetric") != std::string::npos) symmetric = true;
            if (line.find("pattern") != std::string::npos) pattern = true;
        }

        int rows, cols, nnz;
        {
            std::istringstream iss(line);
            iss >> rows >> cols >> nnz;
        }

        std::cout << "Loading matrix: " << rows << " x " << cols << ", NNZ: " << nnz
                  << (symmetric ? " (symmetric)" : "")
                  << (pattern ? " (pattern)" : "") << std::endl;

        // store in hash map to deduplicate
        std::unordered_map<std::pair<int,int>, double, CoordHash> entries;

        int read = 0;
        while (std::getline(file, line) && read < nnz) {
            if (line.empty() || line[0]=='%') continue;

            std::istringstream iss(line);
            int r,c; double val=1.0;
            iss >> r >> c;
            if (!pattern) iss >> val;

            r--; c--; // 0-based

            if (std::abs(val) > 1e-12) {
                entries[{r,c}] += val;
                if (symmetric && r!=c) entries[{c,r}] += val;
            }
            read++;
        }
        file.close();

        std::cout << "Unique entries after deduplication: " << entries.size() << std::endl;

        // convert hash map to CSR
        CSRMatrix csr;
        csr.rows = rows;
        csr.cols = cols;
        csr.nnz = entries.size();
        csr.row_ptr.assign(rows+1,0);
        csr.col_ind.reserve(csr.nnz);
        csr.values.reserve(csr.nnz);

        // gather entries by row
        std::vector<std::tuple<int,int,double>> sorted_entries;
        sorted_entries.reserve(entries.size());
        for (auto &[coord,val]: entries) sorted_entries.emplace_back(coord.first,coord.second,val);

        std::sort(sorted_entries.begin(), sorted_entries.end(),
                  [](const auto &a,const auto &b){return std::get<0>(a)!=std::get<0>(b)? std::get<0>(a)<std::get<0>(b): std::get<1>(a)<std::get<1>(b);});

        for (auto &[r,c,v]: sorted_entries) {
            csr.col_ind.push_back(c);
            csr.values.push_back(v);
            csr.row_ptr[r+1]++;
        }

        for (int i=0;i<rows;i++) csr.row_ptr[i+1]+=csr.row_ptr[i];

        std::cout << "CSR built: " << csr.rows << " x " << csr.cols
                  << ", NNZ: " << csr.nnz
                  << " (density: " << (100.0*csr.nnz/(double)(rows*cols)) << "%)" << std::endl;

        return csr;
    }

    static void save_csr(const CSRMatrix &matrix, const std::string &filename) {
        std::ofstream file(filename);
        if (!file.is_open()) throw std::runtime_error("Cannot open file for writing");

        file << "%%MatrixMarket matrix coordinate real general\n";
        file << "% Generated by GPU-MatGen\n";
        file << matrix.rows << " " << matrix.cols << " " << matrix.nnz << "\n";

        for (int i=0;i<matrix.rows;i++) {
            for (int j=matrix.row_ptr[i]; j<matrix.row_ptr[i+1]; j++) {
                file << (i+1) << " " << (matrix.col_ind[j]+1) << " " << matrix.values[j] << "\n";
            }
        }
        file.close();
    }
};
