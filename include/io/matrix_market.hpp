#pragma once
#include <armadillo>
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <filesystem>
#include <map>
#include <utility>
#include "formats/matrix_formats.hpp"

class MatrixMarketReader {
public:
    static CSRMatrix load_csr(const std::string& filename) {
        if (!std::filesystem::exists(filename)) {
            throw std::runtime_error("File does not exist: " + filename);
        }

        std::ifstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file: " + filename);
        }

        std::string line;
        bool is_symmetric = false;
        bool is_pattern = false;

        /* Parse Matrix Market header */
        while (std::getline(file, line)) {
            if (line[0] == '%') {
                if (line.find("symmetric") != std::string::npos) {
                    is_symmetric = true;
                }
                if (line.find("pattern") != std::string::npos) {
                    is_pattern = true;
                }
                continue;
            }
            break;
        }

        /* Read dimensions */
        int rows, cols, nnz;
        std::istringstream iss(line);
        iss >> rows >> cols >> nnz;

        std::cout << "Loading matrix: " << rows << " x " << cols << ", NNZ: " << nnz;
        if (is_symmetric) std::cout << " (symmetric)";
        if (is_pattern) std::cout << " (pattern)";
        std::cout << std::endl;

        /* Use map to automatically deduplicate and accumulate values */
        std::map<std::pair<int, int>, double> entries_map;

        int entries_read = 0;
        while (std::getline(file, line) && entries_read < nnz) {
            if (line.empty() || line[0] == '%') continue;

            std::istringstream data_iss(line);
            int row, col;
            double value = 1.0;

            data_iss >> row >> col;
            if (!is_pattern) {
                data_iss >> value;
            }

            /* Convert to 0-based */
            row--;
            col--;

            /* Add or accumulate */
            entries_map[{row, col}] += value;

            /* Add transpose for symmetric matrices */
            if (is_symmetric && row != col) {
                entries_map[{col, row}] += value;
            }

            entries_read++;
        }

        file.close();

        std::cout << "Unique entries after deduplication: " << entries_map.size() << std::endl;

        /* Convert map to vectors */
        std::vector<int> row_indices, col_indices;
        std::vector<double> values;

        row_indices.reserve(entries_map.size());
        col_indices.reserve(entries_map.size());
        values.reserve(entries_map.size());

        for (const auto& [coord, val] : entries_map) {
            row_indices.push_back(coord.first);
            col_indices.push_back(coord.second);
            values.push_back(val);
        }

        /* Build sparse matrix using Armadillo */
        arma::umat locations(2, row_indices.size());
        arma::vec vals(values.size());

        for (size_t i = 0; i < row_indices.size(); i++) {
            locations(0, i) = row_indices[i];
            locations(1, i) = col_indices[i];
            vals(i) = values[i];
        }

        arma::sp_mat temp(locations, vals, rows, cols);

        std::cout << "Processed NNZ: " << temp.n_nonzero
                  << " (density: " << (100.0 * temp.n_nonzero / (static_cast<double>(rows) * cols)) << "%)"
                  << std::endl;

        return CSRMatrix::from_arma(temp);
    }

    static void save_csr(const CSRMatrix& matrix, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file for writing: " + filename);
        }

        file << "%%MatrixMarket matrix coordinate real general" << std::endl;
        file << "% Generated by GPU-MatGen" << std::endl;
        file << matrix.rows << " " << matrix.cols << " " << matrix.nnz << std::endl;

        for (int i = 0; i < matrix.rows; i++) {
            for (int j = matrix.row_ptr[i]; j < matrix.row_ptr[i + 1]; j++) {
                file << (i + 1) << " " << (matrix.col_ind[j] + 1) << " "
                     << matrix.values[j] << std::endl;
            }
        }

        file.close();
        std::cout << "Matrix saved to: " << filename << std::endl;
    }
};